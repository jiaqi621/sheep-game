<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>郭了个王</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft Yahei", sans-serif;
        }

        body {
            background-color: #f0e6d2;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        .game-container {
            max-width: 900px;
            width: 100%;
        }

        .game-title {
            text-align: center;
            font-size: 28px;
            color: #8b5a2b;
            margin-bottom: 20px;
        }

        /* 卡片区域样式 - 相对定位用于堆叠 */
        .card-area {
            position: relative;
            background-color: #d9c8b4;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            min-height: 600px;
            overflow: hidden;
        }

        /* 卡片样式 - 绝对定位实现堆叠 */
        .card {
            position: absolute;
            width: 80px;
            height: 105px;
            background-color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, z-index 0.2s;
            background-size: cover;
            background-position: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            user-select: none;
            z-index: 1;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.25);
            z-index: 10;
        }

        .card.disabled {
            opacity: 0;
            cursor: not-allowed;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.2s;
        }

        /* 收集槽样式 */
        .collect-slot {
            display: flex;
            gap: 10px;
            padding: 15px;
            background-color: #e8d9c3;
            border-radius: 8px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .slot {
            width: 70px;
            height: 90px;
            background-color: white;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-size: cover;
            background-position: center;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.2);
        }

        /* 胜利弹窗样式 */
        .victory-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .victory-title {
            font-size: 36px;
            color: #8b5a2b;
            margin-bottom: 20px;
        }

        .victory-text {
            font-size: 18px;
            margin-bottom: 30px;
            color: #555;
        }

        .restart-btn {
            padding: 12px 30px;
            background-color: #8b5a2b;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .restart-btn:hover {
            background-color: #6d4421;
        }

        /* 游戏失败弹窗 */
        .fail-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        /* 响应式适配 */
        @media (max-width: 768px) {
            .card {
                width: 70px;
                height: 90px;
            }
            
            .slot {
                width: 60px;
                height: 80px;
            }
            
            .card-area {
                min-height: 500px;
                padding: 20px;
            }
        }

        @media (max-width: 480px) {
            .card {
                width: 60px;
                height: 80px;
            }
            
            .card-area {
                min-height: 400px;
            }
            
            .victory-title {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="game-title">郭了个王</h1>
        
        <!-- 收集槽 -->
        <div class="collect-slot">
            <div class="slot" id="slot1"></div>
            <div class="slot" id="slot2"></div>
            <div class="slot" id="slot3"></div>
            <div class="slot" id="slot4"></div>
            <div class="slot" id="slot5"></div>
            <div class="slot" id="slot6"></div>
            <div class="slot" id="slot7"></div>
        </div>
        
        <!-- 卡片区域 -->
        <div class="card-area" id="cardArea"></div>
        
        <!-- 胜利弹窗 -->
        <div class="victory-modal" id="victoryModal">
            <div class="modal-content">
                <h2 class="victory-title">恭喜通关！</h2>
                <p class="victory-text">所以你愿意嫁给我吗！</p>
                <button class="restart-btn" id="restartBtn">正在播放语音，请勿退出</button>
            </div>
        </div>

        <!-- 失败弹窗 -->
        <div class="victory-modal" id="failModal">
            <div class="modal-content">
                <h2 class="victory-title">游戏失败</h2>
                <p class="victory-text">收集槽已满，无法继续消除！</p>
                <button class="restart-btn" id="failRestartBtn">重新开始</button>
            </div>
        </div>
    </div>

    <script>
        // 卡片图案链接列表
        const cardImages = [
            "https://s41.ax1x.com/2025/12/24/pZG6NsH.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6deA.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6tQe.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6mM4.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6uL9.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6nsJ.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6VRU.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6ZzF.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZOVf.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZqqP.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZHKI.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZTxA.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZo2d.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZI8H.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZ5Pe.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZh5D.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZfUO.jpg"
        ];

        // 游戏配置（核心：总卡片数=每层数量×层数，必须是3的倍数）
        const GAME_CONFIG = {
            totalLayers: 3,         // 卡片堆叠层数
            cardsPerLayer: 18,      // 每层卡片数量（21是3的倍数，总卡片数=21×1=21）
            slotCount: 7,           // 收集槽数量
            matchCount: 3,          // 消除所需相同卡片数
            victoryAudioUrl: "https://jiaqi621.github.io/sheep-game/qiuhun.m4a",
            cardSpacing: 10         // 卡片间距（越大越分散）
        };

        // 游戏状态
        let gameState = {
            cards: [],              // 卡片数据
            slots: [],              // 收集槽数据
            remainingCards: 0,      // 剩余卡片数
            isGameOver: false       // 游戏是否结束
        };

        // 初始化游戏
        function initGame() {
            // 重置游戏状态
            gameState = {
                cards: [],
                slots: Array(GAME_CONFIG.slotCount).fill(null),
                remainingCards: 0,
                isGameOver: false
            };

            // 隐藏弹窗
            document.getElementById("victoryModal").style.display = "none";
            document.getElementById("failModal").style.display = "none";

            // 生成分散排布的卡片数据
            generateStackedCards();
            
            // 渲染卡片
            renderCards();
            
            // 绑定事件
            bindEvents();
        }

        // 生成分散排布的卡片数据（核心优化：减少堆叠，增加间距）
        function generateStackedCards() {
            const cardArea = document.getElementById("cardArea");
            const areaWidth = cardArea.clientWidth - 100;  // 卡片区域宽度（留边距）
            const areaHeight = cardArea.clientHeight - 100; // 卡片区域高度（留边距）
            const cardWidth = 80;
            const cardHeight = 105;
            const spacing = GAME_CONFIG.cardSpacing; // 卡片间距

            let cardId = 0;
            const allCards = [];
            const totalCards = GAME_CONFIG.totalLayers * GAME_CONFIG.cardsPerLayer; // 总卡片数
            const cardTypes = cardImages.length; // 卡片类型数（9种）
            
            // 关键计算：每种卡片的基础数量（必须是3的倍数）
            const baseCountPerType = Math.floor(totalCards / cardTypes);
            const countPerType = Math.floor(baseCountPerType / 3) * 3;
            let remainingCards = totalCards - (countPerType * cardTypes);
            
            // 计算网格行列数（让卡片按网格分布，减少重叠）
            const colCount = Math.floor(areaWidth / (cardWidth + spacing));
            const rowCount = Math.floor(areaHeight / (cardHeight + spacing));
            // 生成网格坐标池
            const gridPositions = [];
            for (let r = 0; r < rowCount; r++) {
                for (let c = 0; c < colCount; c++) {
                    const x = 50 + c * (cardWidth + spacing);
                    const y = 50 + r * (cardHeight + spacing);
                    gridPositions.push({x, y});
                }
            }

            // 生成每种类型的卡片
            for (let type = 0; type < cardTypes; type++) {
                let currentTypeCount = countPerType;
                if (remainingCards > 0) {
                    const addCount = Math.min(3, remainingCards);
                    currentTypeCount += addCount;
                    remainingCards -= addCount;
                }

                for (let layer = 0; layer < GAME_CONFIG.totalLayers; layer++) {
                    const countInLayer = Math.floor(currentTypeCount / GAME_CONFIG.totalLayers);
                    for (let i = 0; i < countInLayer; i++) {
                        // 优先从网格取坐标，无网格则随机（保证分散）
                        let pos;
                        if (gridPositions.length > 0) {
                            const posIndex = Math.floor(Math.random() * gridPositions.length);
                            pos = gridPositions.splice(posIndex, 1)[0];
                        } else {
                            // 随机坐标也限制偏移范围，减少重叠
                            pos = {
                                x: 50 + Math.random() * (areaWidth - cardWidth - 20),
                                y: 50 + Math.random() * (areaHeight - cardHeight - 20)
                            };
                        }
                        
                        // 层叠z-index降低（减少遮挡），同层z-index差异小
                        const zIndex = layer * 5 + Math.floor(Math.random() * 3);
                        
                        allCards.push({
                            id: `card-${cardId++}`,
                            type: type,
                            image: cardImages[type],
                            x: pos.x,
                            y: pos.y,
                            zIndex: zIndex,
                            isVisible: true,
                            layer: layer
                        });
                    }
                }
            }

            // 兜底校验：确保总数是3的倍数
            const finalTotal = allCards.length;
            if (finalTotal % 3 !== 0) {
                const needAdd = 3 - (finalTotal % 3);
                for (let i = 0; i < needAdd; i++) {
                    const type = Math.floor(Math.random() * cardTypes);
                    const pos = gridPositions.length > 0 
                        ? gridPositions[Math.floor(Math.random() * gridPositions.length)]
                        : {
                            x: 50 + Math.random() * (areaWidth - cardWidth - 20),
                            y: 50 + Math.random() * (areaHeight - cardHeight - 20)
                          };
                    const zIndex = Math.floor(Math.random() * 3);
                    
                    allCards.push({
                        id: `card-${cardId++}`,
                        type: type,
                        image: cardImages[type],
                        x: pos.x,
                        y: pos.y,
                        zIndex: zIndex,
                        isVisible: true,
                        layer: 0
                    });
                }
            }

            // 打乱卡片顺序
            const shuffledCards = shuffleArray(allCards);
            
            // 更新游戏状态
            gameState.cards = shuffledCards;
            gameState.remainingCards = shuffledCards.length;
            
            // 控制台调试信息
            console.log("总卡片数：", gameState.remainingCards, "（是否3的倍数：", gameState.remainingCards % 3 === 0, "）");
            const typeCount = {};
            shuffledCards.forEach(card => {
                typeCount[card.type] = (typeCount[card.type] || 0) + 1;
            });
            console.log("各类型卡片数量：", typeCount);
        }

        // 渲染堆叠卡片
        function renderCards() {
            const cardArea = document.getElementById("cardArea");
            cardArea.innerHTML = "";

            gameState.cards.forEach(card => {
                if (card.isVisible) {
                    const cardElement = document.createElement("div");
                    cardElement.className = "card";
                    cardElement.dataset.id = card.id;
                    cardElement.dataset.type = card.type;
                    cardElement.style.backgroundImage = `url(${card.image})`;
                    
                    // 设置绝对定位和层叠
                    cardElement.style.left = `${card.x}px`;
                    cardElement.style.top = `${card.y}px`;
                    cardElement.style.zIndex = card.zIndex;
                    
                    // 移动端适配
                    if (window.innerWidth <= 768) {
                        cardElement.style.width = "70px";
                        cardElement.style.height = "90px";
                    }
                    if (window.innerWidth <= 480) {
                        cardElement.style.width = "60px";
                        cardElement.style.height = "80px";
                    }
                    
                    cardArea.appendChild(cardElement);
                }
            });
        }

        // 绑定事件
        function bindEvents() {
            // 卡片点击事件
            document.getElementById("cardArea").addEventListener("click", (e) => {
                if (gameState.isGameOver) return;
                
                const cardElement = e.target.closest(".card");
                if (!cardElement) return;

                const cardId = cardElement.dataset.id;
                const cardType = parseInt(cardElement.dataset.type);
                
                // 将卡片放入收集槽
                addToSlot(cardType, cardId);
            });

            // 重新开始按钮事件
            document.getElementById("restartBtn").addEventListener("click", initGame);
            document.getElementById("failRestartBtn").addEventListener("click", initGame);

            // 窗口大小变化时重新渲染
            window.addEventListener("resize", () => {
                if (!gameState.isGameOver) {
                    renderCards();
                }
            });
        }

        // 将卡片添加到收集槽
        function addToSlot(cardType, cardId) {
            // 找到第一个空槽位
            const emptySlotIndex = gameState.slots.findIndex(slot => slot === null);
            
            // 收集槽已满，游戏失败
            if (emptySlotIndex === -1) {
                gameState.isGameOver = true;
                showFailModal();
                return;
            }

            // 更新收集槽
            gameState.slots[emptySlotIndex] = cardType;
            
            // 更新UI
            updateSlotUI();
            
            // 隐藏点击的卡片
            hideCard(cardId);
            
            // 检查是否可以消除
            checkMatch();
            
            // 检查游戏是否胜利
            checkVictory();
        }

        // 隐藏卡片
        function hideCard(cardId) {
            const cardIndex = gameState.cards.findIndex(card => card.id === cardId);
            if (cardIndex !== -1) {
                gameState.cards[cardIndex].isVisible = false;
                gameState.remainingCards--;
                
                // 更新UI（渐隐效果）
                const cardElement = document.querySelector(`.card[data-id="${cardId}"]`);
                if (cardElement) {
                    cardElement.classList.add("disabled");
                }
            }
        }

        // 更新收集槽UI
        function updateSlotUI() {
            gameState.slots.forEach((slotValue, index) => {
                const slotElement = document.getElementById(`slot${index + 1}`);
                if (slotValue === null) {
                    slotElement.style.backgroundImage = "none";
                } else {
                    slotElement.style.backgroundImage = `url(${cardImages[slotValue]})`;
                }
            });
        }

        // 检查是否有可消除的组合
        function checkMatch() {
            // 统计每种卡片在收集槽中的数量
            const typeCount = {};
            gameState.slots.forEach(type => {
                if (type !== null) {
                    typeCount[type] = (typeCount[type] || 0) + 1;
                }
            });

            // 检查是否有达到消除数量的卡片类型
            for (const [type, count] of Object.entries(typeCount)) {
                if (count >= GAME_CONFIG.matchCount) {
                    // 消除对应卡片
                    removeFromSlot(parseInt(type));
                    break;
                }
            }
        }

        // 从收集槽移除卡片
        function removeFromSlot(cardType) {
            let removedCount = 0;
            gameState.slots = gameState.slots.map(slot => {
                if (slot === cardType && removedCount < GAME_CONFIG.matchCount) {
                    removedCount++;
                    return null;
                }
                return slot;
            });

            // 更新UI
            updateSlotUI();
        }

        // 检查游戏是否胜利
        function checkVictory() {
            if (gameState.remainingCards === 0 && !gameState.isGameOver) {
                gameState.isGameOver = true;
                showVictoryModal();
            }
        }

        // 显示胜利弹窗
        function showVictoryModal() {
            const modal = document.getElementById("victoryModal");
            modal.style.display = "flex";
            
            // 播放胜利语音
            playVictoryAudio();
        }

        // 显示失败弹窗
        function showFailModal() {
            const modal = document.getElementById("failModal");
            modal.style.display = "flex";
        }

        // 播放胜利语音（优化兼容性）
        function playVictoryAudio() {
            if (GAME_CONFIG.victoryAudioUrl) {
                try {
                    const audio = new Audio(GAME_CONFIG.victoryAudioUrl);
                    audio.autoplay = true;
                    audio.controls = false;
                    audio.play().catch(err => {
                        console.log("语音播放失败:", err);
                        const modalContent = document.querySelector(".modal-content");
                        const audioBtn = document.createElement("button");
                        audioBtn.className = "restart-btn";
                        audioBtn.style.marginTop = "10px";
                        audioBtn.textContent = "播放胜利语音";
                        audioBtn.onclick = () => audio.play();
                        modalContent.appendChild(audioBtn);
                    });
                } catch (err) {
                    console.log("创建音频对象失败:", err);
                }
            }
        }

        // 数组打乱函数
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // 页面加载完成后初始化游戏
        window.addEventListener("load", initGame);
    </script>
</body>
</html>
