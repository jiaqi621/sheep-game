<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éƒ­äº†ä¸ªç‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft Yahei", sans-serif;
        }

        body {
            background-color: #f0e6d2;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        .game-container {
            max-width: 900px;
            width: 100%;
        }

        .game-title {
            text-align: center;
            font-size: 28px;
            color: #8b5a2b;
            margin-bottom: 20px;
        }

        /* å¡ç‰‡åŒºåŸŸæ ·å¼ - ç›¸å¯¹å®šä½ç”¨äºå †å  */
        .card-area {
            position: relative;
            background-color: #d9c8b4;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            min-height: 600px;
            overflow: hidden;
        }

        /* å¡ç‰‡æ ·å¼ - ç»å¯¹å®šä½å®ç°å †å  */
        .card {
            position: absolute;
            width: 80px;
            height: 105px;
            background-color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, z-index 0.2s;
            background-size: cover;
            background-position: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            user-select: none;
            z-index: 1;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.25);
            z-index: 10;
        }

        .card.disabled {
            opacity: 0;
            cursor: not-allowed;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.2s;
        }

        /* æ”¶é›†æ§½æ ·å¼ */
        .collect-slot {
            display: flex;
            gap: 10px;
            padding: 15px;
            background-color: #e8d9c3;
            border-radius: 8px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .slot {
            width: 70px;
            height: 90px;
            background-color: white;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-size: cover;
            background-position: center;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.2);
        }

        /* èƒœåˆ©å¼¹çª—æ ·å¼ */
        .victory-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .victory-title {
            font-size: 36px;
            color: #8b5a2b;
            margin-bottom: 20px;
        }

        .victory-text {
            font-size: 18px;
            margin-bottom: 30px;
            color: #555;
        }

        .restart-btn {
            padding: 12px 30px;
            background-color: #8b5a2b;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .restart-btn:hover {
            background-color: #6d4421;
        }

        /* æ¸¸æˆå¤±è´¥å¼¹çª— */
        .fail-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        /* èƒŒæ™¯éŸ³ä¹æç¤ºæŒ‰é’® */
        .bgm-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #8b5a2b;
            color: white;
            border: none;
            cursor: pointer;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* å“åº”å¼é€‚é… */
        @media (max-width: 768px) {
            .card {
                width: 70px;
                height: 90px;
            }
            
            .slot {
                width: 60px;
                height: 80px;
            }
            
            .card-area {
                min-height: 500px;
                padding: 20px;
            }
        }

        @media (max-width: 480px) {
            .card {
                width: 60px;
                height: 80px;
            }
            
            .card-area {
                min-height: 400px;
            }
            
            .victory-title {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="game-title">éƒ­äº†ä¸ªç‹</h1>
        
        <!-- æ”¶é›†æ§½ -->
        <div class="collect-slot">
            <div class="slot" id="slot1"></div>
            <div class="slot" id="slot2"></div>
            <div class="slot" id="slot3"></div>
            <div class="slot" id="slot4"></div>
            <div class="slot" id="slot5"></div>
            <div class="slot" id="slot6"></div>
            <div class="slot" id="slot7"></div>
        </div>
        
        <!-- å¡ç‰‡åŒºåŸŸ -->
        <div class="card-area" id="cardArea"></div>
        
        <!-- èƒœåˆ©å¼¹çª— -->
        <div class="victory-modal" id="victoryModal">
            <div class="modal-content">
                <h2 class="victory-title">æ­å–œé€šå…³ï¼</h2>
                <p class="victory-text">æ‰€ä»¥ä½ æ„¿æ„å«ç»™æˆ‘å—ï¼</p>
                <button class="restart-btn" id="restartBtn">æ­£åœ¨æ’­æ”¾è¯­éŸ³ï¼Œè¯·å‹¿é€€å‡º</button>
            </div>
        </div>

        <!-- å¤±è´¥å¼¹çª— -->
        <div class="victory-modal" id="failModal">
            <div class="modal-content">
                <h2 class="victory-title">æ¸¸æˆå¤±è´¥</h2>
                <p class="victory-text">æ”¶é›†æ§½å·²æ»¡ï¼Œæ— æ³•ç»§ç»­æ¶ˆé™¤ï¼</p>
                <button class="restart-btn" id="failRestartBtn">é‡æ–°å¼€å§‹</button>
            </div>
        </div>
    </div>

    <!-- èƒŒæ™¯éŸ³ä¹æ§åˆ¶æŒ‰é’® -->
    <button class="bgm-btn" id="bgmBtn">ğŸµ</button>

    <script>
        // å¡ç‰‡å›¾æ¡ˆé“¾æ¥åˆ—è¡¨
        const cardImages = [
            "https://s41.ax1x.com/2025/12/24/pZG6NsH.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6deA.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6tQe.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6mM4.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6uL9.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6nsJ.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6VRU.jpg",
            "https://s41.ax1x.com/2025/12/24/pZG6ZzF.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZOVf.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZqqP.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZHKI.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZTxA.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZo2d.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZI8H.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZ5Pe.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZh5D.jpg",
            "https://s41.ax1x.com/2025/12/23/pZGZfUO.jpg"
        ];

        // æ¸¸æˆé…ç½®ï¼ˆæ ¸å¿ƒï¼šæ€»å¡ç‰‡æ•°=æ¯å±‚æ•°é‡Ã—å±‚æ•°ï¼Œå¿…é¡»æ˜¯3çš„å€æ•°ï¼‰
        const GAME_CONFIG = {
            totalLayers: 3,         // å¡ç‰‡å †å å±‚æ•°
            cardsPerLayer: 21,      // æ¯å±‚å¡ç‰‡æ•°é‡
            slotCount: 7,           // æ”¶é›†æ§½æ•°é‡
            matchCount: 3,          // æ¶ˆé™¤æ‰€éœ€ç›¸åŒå¡ç‰‡æ•°
            victoryAudioUrl: "https://jiaqi621.github.io/sheep-game/qiuhun.m4a",
            bgmAudioUrl: "https://jiaqi621.github.io/sheep-game/music.mp3", // èƒŒæ™¯éŸ³ä¹URL
            cardSpacing: 5         // å¡ç‰‡é—´è·
        };

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            cards: [],              // å¡ç‰‡æ•°æ®
            slots: [],              // æ”¶é›†æ§½æ•°æ®
            remainingCards: 0,      // å‰©ä½™å¡ç‰‡æ•°
            isGameOver: false       // æ¸¸æˆæ˜¯å¦ç»“æŸ
        };

        // èƒŒæ™¯éŸ³ä¹å¯¹è±¡
        let bgmAudio = null;
        let isBgmPlaying = false;

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState = {
                cards: [],
                slots: Array(GAME_CONFIG.slotCount).fill(null),
                remainingCards: 0,
                isGameOver: false
            };

            // éšè—å¼¹çª—
            document.getElementById("victoryModal").style.display = "none";
            document.getElementById("failModal").style.display = "none";

            // ç”Ÿæˆåˆ†æ•£æ’å¸ƒçš„å¡ç‰‡æ•°æ®
            generateStackedCards();
            
            // æ¸²æŸ“å¡ç‰‡
            renderCards();
            
            // ç»‘å®šäº‹ä»¶
            bindEvents();
        }

        // åˆå§‹åŒ–èƒŒæ™¯éŸ³ä¹
        function initBgm() {
            bgmAudio = new Audio(GAME_CONFIG.bgmAudioUrl);
            bgmAudio.loop = true; // å¾ªç¯æ’­æ”¾
            bgmAudio.volume = 0.5; // è®¾ç½®éŸ³é‡

            // ç»‘å®šèƒŒæ™¯éŸ³ä¹æ§åˆ¶æŒ‰é’®äº‹ä»¶
            const bgmBtn = document.getElementById("bgmBtn");
            bgmBtn.addEventListener("click", toggleBgm);

            // å°è¯•è‡ªåŠ¨æ’­æ”¾ï¼Œå¤±è´¥åˆ™ç­‰å¾…ç”¨æˆ·äº¤äº’
            playBgm().catch(() => {
                console.log("è‡ªåŠ¨æ’­æ”¾å¤±è´¥ï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»æ’­æ”¾");
                bgmBtn.textContent = "ğŸ”Š";
            });

            // ç›‘å¬é¡µé¢ç‚¹å‡»äº‹ä»¶ï¼Œé¦–æ¬¡ç‚¹å‡»åå°è¯•æ’­æ”¾
            document.addEventListener("click", () => {
                if (!isBgmPlaying) {
                    playBgm().catch(() => {});
                }
            }, { once: true });
        }

        // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
        function playBgm() {
            return new Promise((resolve, reject) => {
                bgmAudio.play()
                    .then(() => {
                        isBgmPlaying = true;
                        document.getElementById("bgmBtn").textContent = "ğŸ”‡";
                        resolve();
                    })
                    .catch((err) => {
                        reject(err);
                    });
            });
        }

        // æš‚åœèƒŒæ™¯éŸ³ä¹
        function pauseBgm() {
            bgmAudio.pause();
            isBgmPlaying = false;
            document.getElementById("bgmBtn").textContent = "ğŸ”Š";
        }

        // åˆ‡æ¢èƒŒæ™¯éŸ³ä¹æ’­æ”¾çŠ¶æ€
        function toggleBgm() {
            if (isBgmPlaying) {
                pauseBgm();
            } else {
                playBgm().catch(() => {
                    alert("æ’­æ”¾å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æµè§ˆå™¨è®¾ç½®");
                });
            }
        }

        // ç”Ÿæˆåˆ†æ•£æ’å¸ƒçš„å¡ç‰‡æ•°æ®ï¼ˆæ ¸å¿ƒä¼˜åŒ–ï¼šå‡å°‘å †å ï¼Œå¢åŠ é—´è·ï¼‰
        function generateStackedCards() {
            const cardArea = document.getElementById("cardArea");
            const areaWidth = cardArea.clientWidth - 100;  // å¡ç‰‡åŒºåŸŸå®½åº¦ï¼ˆç•™è¾¹è·ï¼‰
            const areaHeight = cardArea.clientHeight - 100; // å¡ç‰‡åŒºåŸŸé«˜åº¦ï¼ˆç•™è¾¹è·ï¼‰
            const cardWidth = 80;
            const cardHeight = 105;
            const spacing = GAME_CONFIG.cardSpacing; // å¡ç‰‡é—´è·

            let cardId = 0;
            const allCards = [];
            const totalCards = GAME_CONFIG.totalLayers * GAME_CONFIG.cardsPerLayer; // æ€»å¡ç‰‡æ•°
            const cardTypes = cardImages.length; // å¡ç‰‡ç±»å‹æ•°
            
            // å…³é”®è®¡ç®—ï¼šæ¯ç§å¡ç‰‡çš„åŸºç¡€æ•°é‡ï¼ˆå¿…é¡»æ˜¯3çš„å€æ•°ï¼‰
            const baseCountPerType = Math.floor(totalCards / cardTypes);
            const countPerType = Math.floor(baseCountPerType / 3) * 3;
            let remainingCards = totalCards - (countPerType * cardTypes);
            
            // è®¡ç®—ç½‘æ ¼è¡Œåˆ—æ•°ï¼ˆè®©å¡ç‰‡æŒ‰ç½‘æ ¼åˆ†å¸ƒï¼Œå‡å°‘é‡å ï¼‰
            const colCount = Math.floor(areaWidth / (cardWidth + spacing));
            const rowCount = Math.floor(areaHeight / (cardHeight + spacing));
            // ç”Ÿæˆç½‘æ ¼åæ ‡æ± 
            const gridPositions = [];
            for (let r = 0; r < rowCount; r++) {
                for (let c = 0; c < colCount; c++) {
                    const x = 50 + c * (cardWidth + spacing);
                    const y = 50 + r * (cardHeight + spacing);
                    gridPositions.push({x, y});
                }
            }

            // ç”Ÿæˆæ¯ç§ç±»å‹çš„å¡ç‰‡
            for (let type = 0; type < cardTypes; type++) {
                let currentTypeCount = countPerType;
                if (remainingCards > 0) {
                    const addCount = Math.min(3, remainingCards);
                    currentTypeCount += addCount;
                    remainingCards -= addCount;
                }

                for (let layer = 0; layer < GAME_CONFIG.totalLayers; layer++) {
                    const countInLayer = Math.floor(currentTypeCount / GAME_CONFIG.totalLayers);
                    for (let i = 0; i < countInLayer; i++) {
                        // ä¼˜å…ˆä»ç½‘æ ¼å–åæ ‡ï¼Œæ— ç½‘æ ¼åˆ™éšæœºï¼ˆä¿è¯åˆ†æ•£ï¼‰
                        let pos;
                        if (gridPositions.length > 0) {
                            const posIndex = Math.floor(Math.random() * gridPositions.length);
                            pos = gridPositions.splice(posIndex, 1)[0];
                        } else {
                            // éšæœºåæ ‡ä¹Ÿé™åˆ¶åç§»èŒƒå›´ï¼Œå‡å°‘é‡å 
                            pos = {
                                x: 50 + Math.random() * (areaWidth - cardWidth - 20),
                                y: 50 + Math.random() * (areaHeight - cardHeight - 20)
                            };
                        }
                        
                        // å±‚å z-indexé™ä½ï¼ˆå‡å°‘é®æŒ¡ï¼‰ï¼ŒåŒå±‚z-indexå·®å¼‚å°
                        const zIndex = layer * 5 + Math.floor(Math.random() * 3);
                        
                        allCards.push({
                            id: `card-${cardId++}`,
                            type: type,
                            image: cardImages[type],
                            x: pos.x,
                            y: pos.y,
                            zIndex: zIndex,
                            isVisible: true,
                            layer: layer
                        });
                    }
                }
            }

            // å…œåº•æ ¡éªŒï¼šç¡®ä¿æ€»æ•°æ˜¯3çš„å€æ•°
            const finalTotal = allCards.length;
            if (finalTotal % 3 !== 0) {
                const needAdd = 3 - (finalTotal % 3);
                for (let i = 0; i < needAdd; i++) {
                    const type = Math.floor(Math.random() * cardTypes);
                    const pos = gridPositions.length > 0 
                        ? gridPositions[Math.floor(Math.random() * gridPositions.length)]
                        : {
                            x: 50 + Math.random() * (areaWidth - cardWidth - 20),
                            y: 50 + Math.random() * (areaHeight - cardHeight - 20)
                          };
                    const zIndex = Math.floor(Math.random() * 3);
                    
                    allCards.push({
                        id: `card-${cardId++}`,
                        type: type,
                        image: cardImages[type],
                        x: pos.x,
                        y: pos.y,
                        zIndex: zIndex,
                        isVisible: true,
                        layer: 0
                    });
                }
            }

            // æ‰“ä¹±å¡ç‰‡é¡ºåº
            const shuffledCards = shuffleArray(allCards);
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            gameState.cards = shuffledCards;
            gameState.remainingCards = shuffledCards.length;
            
            // æ§åˆ¶å°è°ƒè¯•ä¿¡æ¯
            console.log("æ€»å¡ç‰‡æ•°ï¼š", gameState.remainingCards, "ï¼ˆæ˜¯å¦3çš„å€æ•°ï¼š", gameState.remainingCards % 3 === 0, "ï¼‰");
            const typeCount = {};
            shuffledCards.forEach(card => {
                typeCount[card.type] = (typeCount[card.type] || 0) + 1;
            });
            console.log("å„ç±»å‹å¡ç‰‡æ•°é‡ï¼š", typeCount);
        }

        // æ¸²æŸ“å †å å¡ç‰‡
        function renderCards() {
            const cardArea = document.getElementById("cardArea");
            cardArea.innerHTML = "";

            gameState.cards.forEach(card => {
                if (card.isVisible) {
                    const cardElement = document.createElement("div");
                    cardElement.className = "card";
                    cardElement.dataset.id = card.id;
                    cardElement.dataset.type = card.type;
                    cardElement.style.backgroundImage = `url(${card.image})`;
                    
                    // è®¾ç½®ç»å¯¹å®šä½å’Œå±‚å 
                    cardElement.style.left = `${card.x}px`;
                    cardElement.style.top = `${card.y}px`;
                    cardElement.style.zIndex = card.zIndex;
                    
                    // ç§»åŠ¨ç«¯é€‚é…
                    if (window.innerWidth <= 768) {
                        cardElement.style.width = "70px";
                        cardElement.style.height = "90px";
                    }
                    if (window.innerWidth <= 480) {
                        cardElement.style.width = "60px";
                        cardElement.style.height = "80px";
                    }
                    
                    cardArea.appendChild(cardElement);
                }
            });
        }

        // ç»‘å®šäº‹ä»¶
        function bindEvents() {
            // å¡ç‰‡ç‚¹å‡»äº‹ä»¶
            document.getElementById("cardArea").addEventListener("click", (e) => {
                if (gameState.isGameOver) return;
                
                const cardElement = e.target.closest(".card");
                if (!cardElement) return;

                const cardId = cardElement.dataset.id;
                const cardType = parseInt(cardElement.dataset.type);
                
                // å°†å¡ç‰‡æ”¾å…¥æ”¶é›†æ§½
                addToSlot(cardType, cardId);
            });

            // é‡æ–°å¼€å§‹æŒ‰é’®äº‹ä»¶
            document.getElementById("restartBtn").addEventListener("click", initGame);
            document.getElementById("failRestartBtn").addEventListener("click", initGame);

            // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°æ¸²æŸ“
            window.addEventListener("resize", () => {
                if (!gameState.isGameOver) {
                    renderCards();
                }
            });
        }

        // å°†å¡ç‰‡æ·»åŠ åˆ°æ”¶é›†æ§½
        function addToSlot(cardType, cardId) {
            // æ‰¾åˆ°ç¬¬ä¸€ä¸ªç©ºæ§½ä½
            const emptySlotIndex = gameState.slots.findIndex(slot => slot === null);
            
            // æ”¶é›†æ§½å·²æ»¡ï¼Œæ¸¸æˆå¤±è´¥
            if (emptySlotIndex === -1) {
                gameState.isGameOver = true;
                showFailModal();
                return;
            }

            // æ›´æ–°æ”¶é›†æ§½
            gameState.slots[emptySlotIndex] = cardType;
            
            // æ›´æ–°UI
            updateSlotUI();
            
            // éšè—ç‚¹å‡»çš„å¡ç‰‡
            hideCard(cardId);
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ¶ˆé™¤
            checkMatch();
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦èƒœåˆ©
            checkVictory();
        }

        // éšè—å¡ç‰‡
        function hideCard(cardId) {
            const cardIndex = gameState.cards.findIndex(card => card.id === cardId);
            if (cardIndex !== -1) {
                gameState.cards[cardIndex].isVisible = false;
                gameState.remainingCards--;
                
                // æ›´æ–°UIï¼ˆæ¸éšæ•ˆæœï¼‰
                const cardElement = document.querySelector(`.card[data-id="${cardId}"]`);
                if (cardElement) {
                    cardElement.classList.add("disabled");
                }
            }
        }

        // æ›´æ–°æ”¶é›†æ§½UI
        function updateSlotUI() {
            gameState.slots.forEach((slotValue, index) => {
                const slotElement = document.getElementById(`slot${index + 1}`);
                if (slotValue === null) {
                    slotElement.style.backgroundImage = "none";
                } else {
                    slotElement.style.backgroundImage = `url(${cardImages[slotValue]})`;
                }
            });
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰å¯æ¶ˆé™¤çš„ç»„åˆ
        function checkMatch() {
            // ç»Ÿè®¡æ¯ç§å¡ç‰‡åœ¨æ”¶é›†æ§½ä¸­çš„æ•°é‡
            const typeCount = {};
            gameState.slots.forEach(type => {
                if (type !== null) {
                    typeCount[type] = (typeCount[type] || 0) + 1;
                }
            });

            // æ£€æŸ¥æ˜¯å¦æœ‰è¾¾åˆ°æ¶ˆé™¤æ•°é‡çš„å¡ç‰‡ç±»å‹
            for (const [type, count] of Object.entries(typeCount)) {
                if (count >= GAME_CONFIG.matchCount) {
                    // æ¶ˆé™¤å¯¹åº”å¡ç‰‡
                    removeFromSlot(parseInt(type));
                    break;
                }
            }
        }

        // ä»æ”¶é›†æ§½ç§»é™¤å¡ç‰‡
        function removeFromSlot(cardType) {
            let removedCount = 0;
            gameState.slots = gameState.slots.map(slot => {
                if (slot === cardType && removedCount < GAME_CONFIG.matchCount) {
                    removedCount++;
                    return null;
                }
                return slot;
            });

            // æ›´æ–°UI
            updateSlotUI();
        }

        // æ£€æŸ¥æ¸¸æˆæ˜¯å¦èƒœåˆ©
        function checkVictory() {
            if (gameState.remainingCards === 0 && !gameState.isGameOver) {
                gameState.isGameOver = true;
                showVictoryModal();
            }
        }

        // æ˜¾ç¤ºèƒœåˆ©å¼¹çª—
        function showVictoryModal() {
            const modal = document.getElementById("victoryModal");
            modal.style.display = "flex";
            
            // æ’­æ”¾èƒœåˆ©è¯­éŸ³
            playVictoryAudio();
        }

        // æ˜¾ç¤ºå¤±è´¥å¼¹çª—
        function showFailModal() {
            const modal = document.getElementById("failModal");
            modal.style.display = "flex";
        }

        // æ’­æ”¾èƒœåˆ©è¯­éŸ³ï¼ˆä¼˜åŒ–å…¼å®¹æ€§ï¼‰
        function playVictoryAudio() {
            if (GAME_CONFIG.victoryAudioUrl) {
                try {
                    const audio = new Audio(GAME_CONFIG.victoryAudioUrl);
                    audio.autoplay = true;
                    audio.controls = false;
                    audio.play().catch(err => {
                        console.log("è¯­éŸ³æ’­æ”¾å¤±è´¥:", err);
                        const modalContent = document.querySelector(".modal-content");
                        const audioBtn = document.createElement("button");
                        audioBtn.className = "restart-btn";
                        audioBtn.style.marginTop = "10px";
                        audioBtn.textContent = "æ’­æ”¾èƒœåˆ©è¯­éŸ³";
                        audioBtn.onclick = () => audio.play();
                        modalContent.appendChild(audioBtn);
                    });
                } catch (err) {
                    console.log("åˆ›å»ºéŸ³é¢‘å¯¹è±¡å¤±è´¥:", err);
                }
            }
        }

        // æ•°ç»„æ‰“ä¹±å‡½æ•°
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ¸¸æˆå’ŒèƒŒæ™¯éŸ³ä¹
        window.addEventListener("load", () => {
            initGame();
            initBgm();
        });
    </script>
</body>
</html>
